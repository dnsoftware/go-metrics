
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dnsoftware/go-metrics/cmd/agent/main.go (0.0%)</option>
				
				<option value="file1">github.com/dnsoftware/go-metrics/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/dnsoftware/go-metrics/cmd/staticlint/main.go (0.0%)</option>
				
				<option value="file3">github.com/dnsoftware/go-metrics/internal/agent/app/app.go (0.0%)</option>
				
				<option value="file4">github.com/dnsoftware/go-metrics/internal/agent/app/flags.go (77.8%)</option>
				
				<option value="file5">github.com/dnsoftware/go-metrics/internal/agent/domain/metrics.go (37.8%)</option>
				
				<option value="file6">github.com/dnsoftware/go-metrics/internal/agent/infrastructure/retry.go (0.0%)</option>
				
				<option value="file7">github.com/dnsoftware/go-metrics/internal/agent/infrastructure/webapi.go (1.4%)</option>
				
				<option value="file8">github.com/dnsoftware/go-metrics/internal/logger/logger.go (90.0%)</option>
				
				<option value="file9">github.com/dnsoftware/go-metrics/internal/server/app/app.go (0.0%)</option>
				
				<option value="file10">github.com/dnsoftware/go-metrics/internal/server/collector/collector.go (65.6%)</option>
				
				<option value="file11">github.com/dnsoftware/go-metrics/internal/server/collector/mocks/mock_backup_storage.go (21.2%)</option>
				
				<option value="file12">github.com/dnsoftware/go-metrics/internal/server/config/config.go (0.0%)</option>
				
				<option value="file13">github.com/dnsoftware/go-metrics/internal/server/handlers/gzip.go (0.0%)</option>
				
				<option value="file14">github.com/dnsoftware/go-metrics/internal/server/handlers/http.go (100.0%)</option>
				
				<option value="file15">github.com/dnsoftware/go-metrics/internal/server/handlers/middlewares.go (63.0%)</option>
				
				<option value="file16">github.com/dnsoftware/go-metrics/internal/server/handlers/routes.go (68.7%)</option>
				
				<option value="file17">github.com/dnsoftware/go-metrics/internal/staticlint/app/app.go (0.0%)</option>
				
				<option value="file18">github.com/dnsoftware/go-metrics/internal/staticlint/noosexit/noosexit.go (95.7%)</option>
				
				<option value="file19">github.com/dnsoftware/go-metrics/internal/storage/filebackup.go (77.3%)</option>
				
				<option value="file20">github.com/dnsoftware/go-metrics/internal/storage/memory.go (87.2%)</option>
				
				<option value="file21">github.com/dnsoftware/go-metrics/internal/storage/postgresql.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "github.com/dnsoftware/go-metrics/internal/agent/app"

func main() <span class="cov0" title="0">{
        app.AgentRun()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"

        "github.com/dnsoftware/go-metrics/internal/server/app"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        fmt.Printf("Build version: %s\n", buildVersion)
        fmt.Printf("Build date: %s\n", buildDate)
        fmt.Printf("Build commit: %s\n", buildCommit)

        app.ServerRun()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Статический анализатор staticlint.
//
// Запускается из директории проекта командой: make staticlink.
//
// # Анализаторы
//
// • стандартные статические анализаторы пакета golang.org/x/tools/go/analysis/passes.
// • анализаторы staticcheck.io класса SA - выявляют ошибки и проблемы с производительностью.
// • анализаторы staticcheck.io класса quickfix - рефакторинг кода.
// • анализаторы staticcheck.io класса simple - упрощение кода.
// • анализаторы staticcheck.io класса tylecheck -         содержит анализы, обеспечивающие соблюдение правил стиля.
//
// • анализатор bodyclose - проверяет, правильно ли закрыт res.Body.
// • анализатор ginkgolinter - Обеспечивает соблюдение стандартов использования ginkgo и gomega.
//
// • собственный анализатор noosexit - анализирует вызовы функции os.Exit в пакете main функции main(). При наличии выдает предупреждение.
package main

import (
        "github.com/dnsoftware/go-metrics/internal/staticlint/app"
)

func main() <span class="cov0" title="0">{

        app.StaticCheckerRun()

}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package app Приложение Агента
package app

import (
        "net/http"
        _ "net/http/pprof"

        "github.com/dnsoftware/go-metrics/internal/agent/domain"
        "github.com/dnsoftware/go-metrics/internal/agent/infrastructure"
        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/dnsoftware/go-metrics/internal/storage"
)

func AgentRun() <span class="cov0" title="0">{
        flags := NewAgentFlags()

        repository := storage.NewMemStorage()

        // для нового API - constants.ApplicationJson (для старого - constants.TextPlain)
        sender := infrastructure.NewWebSender("http", &amp;flags, constants.ApplicationJSON)

        metrics := domain.NewMetrics(repository, &amp;sender, &amp;flags)

        go func() </span><span class="cov0" title="0">{
                http.ListenAndServe(constants.AgentPprofAddr, nil) // запускаем сервер для pprof
        }</span>()

        <span class="cov0" title="0">metrics.Start()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "flag"
        "log"

        "github.com/caarlos0/env/v6"
        "github.com/dnsoftware/go-metrics/internal/constants"
)

type AgentFlags struct {
        flagRunAddr        string
        flagReportInterval int64
        flagPollInterval   int64
        flagCryptoKey      string
        flagRateLimit      int
}

// NewAgentFlags обрабатывает аргументы командной строки
// возвращает соответствующую структуру
// а также проверяет переменные окружения и задействует их при наличии
func NewAgentFlags() AgentFlags <span class="cov8" title="1">{
        type Config struct {
                RunAddr        string `env:"ADDRESS"`
                ReportInterval int64  `env:"REPORT_INTERVAL"`
                PollInterval   int64  `env:"POLL_INTERVAL"`
                CryptoKey      string `env:"KEY"`
                RateLimit      int    `env:"RATE_LIMIT"`
        }

        var (
                cfg   Config
                flags AgentFlags
        )

        err := env.Parse(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">flag.StringVar(&amp;flags.flagRunAddr, "a", constants.ServerDefault, "address and port to run server")
        flag.Int64Var(&amp;flags.flagReportInterval, "r", constants.ReportInterval, "report interval")
        flag.Int64Var(&amp;flags.flagPollInterval, "p", constants.PollInterval, "poll interval")
        flag.StringVar(&amp;flags.flagCryptoKey, "k", "", "crypto key")
        flag.IntVar(&amp;flags.flagRateLimit, "l", constants.RateLimit, "poll interval")

        flag.Parse()

        // переменные окружения
        if cfg.RunAddr != "" </span><span class="cov0" title="0">{
                flags.flagRunAddr = cfg.RunAddr
        }</span>

        <span class="cov8" title="1">if cfg.ReportInterval != 0 </span><span class="cov0" title="0">{
                flags.flagReportInterval = cfg.ReportInterval
        }</span>

        <span class="cov8" title="1">if cfg.PollInterval != 0 </span><span class="cov0" title="0">{
                flags.flagPollInterval = cfg.PollInterval
        }</span>

        <span class="cov8" title="1">if cfg.CryptoKey != "" </span><span class="cov0" title="0">{
                flags.flagCryptoKey = cfg.CryptoKey
        }</span>

        <span class="cov8" title="1">if cfg.RateLimit != 0 </span><span class="cov0" title="0">{
                flags.flagRateLimit = cfg.RateLimit
        }</span>

        <span class="cov8" title="1">return flags</span>
}

func (f *AgentFlags) RunAddr() string <span class="cov8" title="1">{
        return f.flagRunAddr
}</span>

func (f *AgentFlags) ReportInterval() int64 <span class="cov8" title="1">{
        return f.flagReportInterval
}</span>

func (f *AgentFlags) PollInterval() int64 <span class="cov8" title="1">{
        return f.flagPollInterval
}</span>

func (f *AgentFlags) CryptoKey() string <span class="cov8" title="1">{
        return f.flagCryptoKey
}</span>

func (f *AgentFlags) RateLimit() int <span class="cov8" title="1">{
        return f.flagRateLimit
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package domain включает в себя бизнес логика агента. Получение метрик и отправка их на сервер
package domain

import (
        "context"
        "encoding/json"
        "fmt"
        "math/rand"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "reflect"
        "runtime"
        "strconv"
        "sync"
        "syscall"
        "time"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/dnsoftware/go-metrics/internal/logger"
        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/mem"
)

// AgentStorage интерфейс хранилаща для агента.
type AgentStorage interface {
        // SetGauge сохранение метрики типа gauge в хранилище.
        // Параметры: name - название метрики, value - ее значение.
        SetGauge(ctx context.Context, name string, value float64) error

        // GetGauge получение значения метрики типа gauge из хранилища.
        // Параметры: name - название метрики.
        GetGauge(ctx context.Context, name string) (float64, error)

        // SetCounter сохранение метрики типа counter в хранилище.
        // Параметры: name - название метрики, value - ее значение.
        SetCounter(ctx context.Context, name string, value int64) error

        // GetCounter получение значения метрики типа counter из хранилища.
        // Параметры: name - название метрики.
        GetCounter(ctx context.Context, name string) (int64, error)
}

// MetricsSender отправка метрик на сервер.
type MetricsSender interface {
        // SendData отправка одной метрики на сервер.
        SendData(ctx context.Context, mType string, name string, value string) error

        // SendDataBatch отправка метрик на сервер пакетом. Параметр jsonData - данные по
        // метрикам в формате json в виде среза байт
        SendDataBatch(ctx context.Context, jsonData []byte) error
}

// Flags получение значения флагов командной строки запуска агента
type Flags interface {
        ReportInterval() int64
        PollInterval() int64
        RateLimit() int
}

// Metrics основная структура агента. Получение, промежуточное сохранение, отправка данных на сервер.
type Metrics struct {
        metrics         runtime.MemStats
        storage         AgentStorage
        sender          MetricsSender
        pollInterval    int64
        reportInterval  int64
        gopcMetricsList []string
        rateLimit       int
}

// MetricsItem структура для отправки json данных на сервер
type MetricsItem struct {
        ID    string   `json:"id"`              // имя метрики
        MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
        Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
        Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
}

// gaugeMetricsList названия всех доступных gauge метрик
var gaugeMetricsList = []string{"Alloc", "BuckHashSys", "Frees", "GCCPUFraction", "GCSys", "HeapAlloc", "HeapIdle", "HeapInuse", "HeapObjects", "HeapReleased", "HeapSys", "LastGC", "Lookups", "MCacheInuse", "MCacheSys", "MSpanInuse", "MSpanSys", "Mallocs", "NextGC", "NumForcedGC", "NumGC", "OtherSys", "PauseTotalNs", "StackInuse", "StackSys", "Sys", "TotalAlloc", "RandomValue"}

func NewMetrics(storage AgentStorage, sender MetricsSender, flags Flags) Metrics <span class="cov3" title="3">{

        gopcMetricsList := []string{constants.TotalMemory, constants.FreeMemory}

        cpuCount, _ := cpu.Counts(false)
        for i := 1; i &lt;= cpuCount; i++ </span><span class="cov7" title="12">{
                gopcMetricsList = append(gopcMetricsList, constants.CPUutilization+strconv.Itoa(i))
        }</span>

        <span class="cov3" title="3">return Metrics{
                storage:         storage,
                sender:          sender,
                pollInterval:    flags.PollInterval(),
                reportInterval:  flags.ReportInterval(),
                rateLimit:       flags.RateLimit(),
                gopcMetricsList: gopcMetricsList,
        }</span>
}

// Start старт работы агента - запуск горутин по получению и отправке метрик.
func (m *Metrics) Start() <span class="cov0" title="0">{
        var wg sync.WaitGroup

        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        // обновление метрик
        wg.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                fmt.Println("\nОбновление метрик завершено...")
                                return</span>
                        default:<span class="cov0" title="0">
                                m.UpdateMetrics()
                                time.Sleep(time.Duration(m.pollInterval) * time.Second)</span>
                        }
                }
        }()

        // для gopcutils
        <span class="cov0" title="0">wg.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                fmt.Println("\nОбновление метрик gopcutils завершено...")
                                return</span>
                        default:<span class="cov0" title="0">
                                m.UpdateGopcMetrics()
                                time.Sleep(time.Duration(m.pollInterval) * time.Second)</span>
                        }
                }
        }()

        // отправка метрик

        // создаем буферизованный канал для принятия задач в воркер
        <span class="cov0" title="0">jobsCh := make(chan []byte, constants.ChannelCap)

        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                fmt.Println("\nПодготовка пакетов на отправку завершена...")
                                return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(time.Duration(m.reportInterval) * time.Second)
                                // в старом API было m.sendMetrics()
                                m.sendMetricsBatch(ctx, jobsCh)</span>
                        }
                }
        }()

        // отправка пакетов, поступающих в очередь
        <span class="cov0" title="0">rateLimitChan := make(chan struct{}, constants.RateLimit)
        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                defer close(rateLimitChan)

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                fmt.Println("\nОтправка метрик завершена...") ///
                                return</span>
                        case job := &lt;-jobsCh:<span class="cov0" title="0">
                                rateLimitChan &lt;- struct{}{}
                                go m.worker(job, rateLimitChan)</span>
                        }
                }
        }()

        <span class="cov0" title="0">wg.Wait()

        fmt.Println("\nПрограмма завершена!")</span>
}

// UpdateMetricsReflect сохранение метрик в базу с использованием рефлексии.
func (m *Metrics) UpdateMetricsReflect() <span class="cov1" title="1">{
        ctx := context.Background()

        rnd := rand.New(rand.NewSource(time.Now().UnixNano()))

        mCounter, err := m.storage.GetCounter(ctx, constants.PollCount)
        if err != nil </span><span class="cov1" title="1">{
                logger.Log().Error(err.Error())
        }</span>

        <span class="cov1" title="1">runtime.ReadMemStats(&amp;m.metrics)

        for _, metricName := range gaugeMetricsList </span><span class="cov10" title="28">{
                mType, ok := reflect.TypeOf(&amp;m.metrics).Elem().FieldByName(metricName)
                if ok </span><span class="cov9" title="27">{ // если поле найдено
                        tp := mType.Type.Kind().String()
                        metricValue := reflect.ValueOf(&amp;m.metrics).Elem().FieldByName(metricName)

                        switch tp </span>{
                        case "uint64":<span class="cov9" title="24">
                                m.storage.SetGauge(ctx, metricName, float64(metricValue.Uint()))</span>
                        case "uint32":<span class="cov2" title="2">
                                m.storage.SetGauge(ctx, metricName, float64(metricValue.Uint()))</span>
                        case "float64":<span class="cov1" title="1">
                                m.storage.SetGauge(ctx, metricName, metricValue.Float())</span>
                        default:<span class="cov0" title="0">
                                // действия при неучтенном типе
                                logger.Log().Error("неучтенный тип метрики: " + tp)</span>
                        }

                        <span class="cov9" title="27">mCounter++</span>
                } else<span class="cov1" title="1"> if metricName == constants.RandomValue </span><span class="cov1" title="1">{
                        m.storage.SetGauge(ctx, metricName, rnd.Float64())

                        mCounter++
                }</span> else<span class="cov0" title="0"> {
                        logger.Log().Warn("Metric not found: " + metricName)

                        continue</span>
                }
        }

        <span class="cov1" title="1">m.storage.SetCounter(ctx, constants.PollCount, mCounter)</span>
}

// UpdateMetrics сохранение метрик в базу явным образом.
// работает быстрее
func (m *Metrics) UpdateMetrics() <span class="cov1" title="1">{
        ctx := context.Background()

        rnd := rand.New(rand.NewSource(time.Now().UnixNano()))

        mCounter, err := m.storage.GetCounter(ctx, constants.PollCount)
        if err != nil </span><span class="cov1" title="1">{
                logger.Log().Error(err.Error())
        }</span>

        <span class="cov1" title="1">runtime.ReadMemStats(&amp;m.metrics)

        m.storage.SetGauge(ctx, "Alloc", float64(m.metrics.Alloc))
        m.storage.SetGauge(ctx, "TotalAlloc", float64(m.metrics.TotalAlloc))
        m.storage.SetGauge(ctx, "Sys", float64(m.metrics.Sys))
        m.storage.SetGauge(ctx, "Lookups", float64(m.metrics.Lookups))
        m.storage.SetGauge(ctx, "Mallocs", float64(m.metrics.Mallocs))
        m.storage.SetGauge(ctx, "Frees", float64(m.metrics.Frees))
        m.storage.SetGauge(ctx, "HeapAlloc", float64(m.metrics.HeapAlloc))
        m.storage.SetGauge(ctx, "HeapSys", float64(m.metrics.HeapSys))
        m.storage.SetGauge(ctx, "HeapIdle", float64(m.metrics.HeapIdle))
        m.storage.SetGauge(ctx, "HeapInuse", float64(m.metrics.HeapInuse))
        m.storage.SetGauge(ctx, "HeapReleased", float64(m.metrics.HeapReleased))
        m.storage.SetGauge(ctx, "HeapObjects", float64(m.metrics.HeapObjects))
        m.storage.SetGauge(ctx, "StackInuse", float64(m.metrics.StackInuse))
        m.storage.SetGauge(ctx, "StackSys", float64(m.metrics.StackSys))
        m.storage.SetGauge(ctx, "MSpanInuse", float64(m.metrics.MSpanInuse))
        m.storage.SetGauge(ctx, "MSpanSys", float64(m.metrics.MSpanSys))
        m.storage.SetGauge(ctx, "MCacheInuse", float64(m.metrics.MCacheInuse))
        m.storage.SetGauge(ctx, "MCacheSys", float64(m.metrics.MCacheSys))
        m.storage.SetGauge(ctx, "BuckHashSys", float64(m.metrics.BuckHashSys))
        m.storage.SetGauge(ctx, "GCSys", float64(m.metrics.GCSys))
        m.storage.SetGauge(ctx, "OtherSys", float64(m.metrics.OtherSys))
        m.storage.SetGauge(ctx, "NextGC", float64(m.metrics.NextGC))
        m.storage.SetGauge(ctx, "LastGC", float64(m.metrics.LastGC))
        m.storage.SetGauge(ctx, "PauseTotalNs", float64(m.metrics.PauseTotalNs))
        m.storage.SetGauge(ctx, "NumGC", float64(m.metrics.NumGC))
        m.storage.SetGauge(ctx, "NumForcedGC", float64(m.metrics.NumForcedGC))
        m.storage.SetGauge(ctx, "GCCPUFraction", m.metrics.GCCPUFraction)
        m.storage.SetGauge(ctx, constants.RandomValue, rnd.Float64())
        mCounter += 28

        m.storage.SetCounter(ctx, constants.PollCount, mCounter)</span>
}

// UpdateGopcMetrics получение системных и аппаратных метрик и сохранение их в базу.
func (m *Metrics) UpdateGopcMetrics() <span class="cov1" title="1">{
        ctx := context.Background()

        mCounter, err := m.storage.GetCounter(ctx, constants.PollCount)
        if err != nil </span><span class="cov1" title="1">{
                logger.Log().Error(err.Error())
        }</span>

        <span class="cov1" title="1">vm, _ := mem.VirtualMemory()

        m.storage.SetGauge(ctx, constants.TotalMemory, float64(vm.Total))
        m.storage.SetGauge(ctx, constants.FreeMemory, float64(vm.Free))
        mCounter += 2

        cc, _ := cpu.Percent(time.Second*time.Duration(constants.CPUIntervalUtilization), true)
        for key, val := range cc </span><span class="cov4" title="4">{
                m.storage.SetGauge(ctx, constants.CPUutilization+strconv.Itoa(key+1), val)
                mCounter++
        }</span>

        <span class="cov1" title="1">m.storage.SetCounter(ctx, constants.PollCount, mCounter)</span>
}

// sendMetrics отправка метрик на сервер
func (m *Metrics) sendMetrics() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.HTTPContextTimeout)
        defer cancel()

        // gauge
        allGaugeMetrics := append(gaugeMetricsList, m.gopcMetricsList...)
        for _, metricName := range allGaugeMetrics </span><span class="cov0" title="0">{
                val, err := m.storage.GetGauge(ctx, metricName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log().Error(err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">err = m.SendGauge(ctx, metricName, val)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log().Error(err.Error())
                        continue</span>
                }
        }

        // counter
        <span class="cov0" title="0">cValue, err := m.storage.GetCounter(ctx, constants.PollCount)
        if err != nil </span><span class="cov0" title="0">{
                cValue = 0
        }</span>

        <span class="cov0" title="0">err = m.SendCounter(ctx, constants.PollCount, cValue)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error("Set PollCounter error: " + err.Error())
        }</span>

        <span class="cov0" title="0">_ = m.storage.SetCounter(ctx, constants.PollCount, 0)</span>
}

// worker воркер по пакетной отправке метрик на сервер.
func (m *Metrics) worker(job []byte, rateLimitChan chan struct{}) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.HTTPContextTimeout)
        defer cancel()

        err := m.sender.SendDataBatch(ctx, job)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error("Send job error: " + err.Error())
        }</span>

        <span class="cov0" title="0">&lt;-rateLimitChan</span>
}

// отправка метрик мини-пакетами
func (m *Metrics) sendMetricsBatch(ctx context.Context, jobsCh chan []byte) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, constants.HTTPContextTimeout)
        defer cancel()

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                fmt.Println("\nОтправка пакетов завершена...") ///
                return</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">var batch []MetricsItem

        // gauges
        allGaugeMetrics := append(gaugeMetricsList, m.gopcMetricsList...)
        for _, metricName := range allGaugeMetrics </span><span class="cov0" title="0">{
                val, err := m.storage.GetGauge(ctx, metricName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log().Error(err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">batch = append(batch, MetricsItem{
                        ID:    metricName,
                        MType: constants.Gauge,
                        Value: &amp;val,
                })</span>
        }

        // counters
        <span class="cov0" title="0">pollCount, err := m.storage.GetCounter(ctx, constants.PollCount)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error(err.Error())

                pollCount = 0
        }</span>

        <span class="cov0" title="0">batch = append(batch, MetricsItem{
                ID:    constants.PollCount,
                MType: constants.Counter,
                Delta: &amp;pollCount,
        })

        // отправляем задачи, упакованные в мелкие пакеты, воркерам
        var (
                miniBatch []MetricsItem
                batchData []byte
        )

        i := 0

        for _, mi := range batch </span><span class="cov0" title="0">{
                miniBatch = append(miniBatch, mi)
                i++

                if i == constants.BatchItemCount </span><span class="cov0" title="0">{
                        batchData, err = json.Marshal(miniBatch)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log().Error(err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">jobsCh &lt;- batchData

                        i = 0
                        miniBatch = nil</span>
                }
        }

        <span class="cov0" title="0">if len(miniBatch) &gt; 0 </span><span class="cov0" title="0">{
                batchData, err = json.Marshal(miniBatch)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log().Error(err.Error())
                        return
                }</span>
                <span class="cov0" title="0">jobsCh &lt;- batchData</span>
        }

}

// SendGauge отправляет одну метрику типа gauge на сервер
func (m *Metrics) SendGauge(ctx context.Context, name string, value float64) error <span class="cov0" title="0">{
        err := m.sender.SendData(ctx, constants.Gauge, name, fmt.Sprintf("%f", value))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SendCounter отправляет одну метрику типа counter на сервер
func (m *Metrics) SendCounter(ctx context.Context, name string, value int64) error <span class="cov0" title="0">{
        v := strconv.FormatInt(value, 10)

        err := m.sender.SendData(ctx, constants.Counter, name, v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsGauge проверка на допустимую метрику gauge
func (m *Metrics) IsGauge(name string) bool <span class="cov0" title="0">{
        for _, val := range gaugeMetricsList </span><span class="cov0" title="0">{
                if val == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package infrastructure HTTP запросы к внешним сервисам
package infrastructure

import (
        "net/http"
        "strings"
        "time"

        "github.com/dnsoftware/go-metrics/internal/constants"
)

// retryRequest retriable error HTTP запрос
// durations - срез периодов, через которые делается повторная попытка
func retryRequest(r *http.Request) error <span class="cov0" title="0">{
        client := &amp;http.Client{}
        durations := strings.Split(constants.HTTPAttemtPeriods, ",")

        resp, err := client.Do(r)
        if err != nil </span><span class="cov0" title="0">{
                for _, duration := range durations </span><span class="cov0" title="0">{
                        d, _ := time.ParseDuration(duration)
                        time.Sleep(d)

                        respRetry, errRetry := client.Do(r)
                        if errRetry == nil </span><span class="cov0" title="0">{
                                respRetry.Body.Close()
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">resp.Body.Close()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package infrastructure

import (
        "bytes"
        "compress/gzip"
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/dnsoftware/go-metrics/internal/logger"
)

// Flags возвращает значения флагов запуска программы
type Flags interface {
        RunAddr() string
        CryptoKey() string
}

// WebSender отправляет данные на сервер.
type WebSender struct {
        protocol    string
        domain      string
        contentType string
        cryptoKey   string
}

// Metrics структура для отправки json данных на сервер
type Metrics struct {
        ID    string   `json:"id"`              // имя метрики
        MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
        Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
        Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
}

func NewWebSender(protocol string, flags Flags, contentType string) WebSender <span class="cov10" title="3">{
        return WebSender{
                protocol:    protocol,
                domain:      flags.RunAddr(),
                contentType: contentType,
                cryptoKey:   flags.CryptoKey(),
        }
}</span>

// SendData Отправка по одной метрике, через url или через json
func (w *WebSender) SendData(ctx context.Context, mType string, name string, value string) error <span class="cov0" title="0">{
        switch w.contentType </span>{
        case constants.TextPlain, constants.TextHTML:<span class="cov0" title="0">
                return w.sendPlain(ctx, mType, name, value)</span>
        case constants.ApplicationJSON:<span class="cov0" title="0">
                return w.sendJSON(ctx, mType, name, value)</span>
        }

        <span class="cov0" title="0">return errors.New("bad send data content type")</span>
}

// SendDataBatch отправка данных пакетом в json формате
func (w *WebSender) SendDataBatch(ctx context.Context, data []byte) error <span class="cov0" title="0">{
        url := w.protocol + "://" + w.domain + "/" + constants.UpdatesAction

        request, err := NewAgentRequest(ctx, http.MethodPost, url, data, w.cryptoKey)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">request.Header.Set("Content-Type", w.contentType)
        request.Header.Set("Content-Encoding", constants.EncodingGzip)

        err = retryRequest(request)

        return err</span>
}

// sendPlain отправка метрики на сервер простым текстом через url.
func (w *WebSender) sendPlain(ctx context.Context, mType string, name string, value string) error <span class="cov0" title="0">{
        url := w.protocol + "://" + w.domain + "/" + constants.UpdateAction + "/" + mType + "/" + name + "/" + value

        request, err := NewAgentRequest(ctx, http.MethodPost, url, nil, w.cryptoKey)
        if err != nil </span><span class="cov0" title="0">{
                // обрабатываем ошибку
                logger.Log().Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">request.Header.Set("Content-Type", w.contentType)

        client := &amp;http.Client{}

        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()

        return nil</span>
}

// sendJSON отпрвка данных на сервер в json формате.
func (w *WebSender) sendJSON(ctx context.Context, mType string, name string, value string) error <span class="cov0" title="0">{
        url := w.protocol + "://" + w.domain + "/" + constants.UpdateAction

        data := Metrics{
                ID:    name,
                MType: mType,
        }

        switch mType </span>{
        case constants.Gauge:<span class="cov0" title="0">
                v, _ := strconv.ParseFloat(value, 64)
                data.Value = &amp;v</span>
        case constants.Counter:<span class="cov0" title="0">
                v, _ := strconv.ParseInt(value, 10, 64)
                data.Delta = &amp;v</span>
        }

        <span class="cov0" title="0">body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">request, err := NewAgentRequest(ctx, http.MethodPost, url, body, w.cryptoKey)
        if err != nil </span><span class="cov0" title="0">{
                // обрабатываем ошибку
                logger.Log().Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">request.Header.Set("Content-Type", w.contentType)
        request.Header.Set("Content-Encoding", constants.EncodingGzip)

        client := &amp;http.Client{}

        resp, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return nil</span>
}

// GetGzipReader gzip компрессор входяшего потока байтов
// возврат *bytes.Buffer, реализующего интерфейс io.Reader
func GetGzipReader(data []byte) (*bytes.Buffer, error) <span class="cov0" title="0">{
        buf := bytes.NewBuffer(nil)

        zb := gzip.NewWriter(buf)

        _, err := zb.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">zb.Close()

        return buf, nil</span>
}

func hash(value []byte, key string) string <span class="cov0" title="0">{
        data := append(value, []byte(key)...)
        h := sha256.Sum256(data)

        return hex.EncodeToString(h[:])
}</span>

func NewAgentRequest(ctx context.Context, method, url string, data []byte, cryptoKey string) (*http.Request, error) <span class="cov0" title="0">{
        buf := &amp;bytes.Buffer{}

        var err error
        // gzip сжатие
        if data != nil </span><span class="cov0" title="0">{
                buf, err = GetGzipReader(data)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log().Error(err.Error())
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">request, err := http.NewRequestWithContext(ctx, method, url, buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">h := hash(buf.Bytes(), cryptoKey)
        if cryptoKey != "" </span><span class="cov0" title="0">{
                request.Header.Set(constants.HashHeaderName, h)
        }</span>

        <span class="cov0" title="0">return request, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package logger Синглтон логирования
package logger

import (
        "fmt"
        "log"
        "os"
        "sync"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type logger struct {
        *zap.Logger
        filename string
}

var projectLogger *logger
var once sync.Once

// Log Получение синглтона логгера
func Log() *logger <span class="cov10" title="20">{
        once.Do(func() </span><span class="cov3" title="2">{
                var err error

                projectLogger, err = createLogger(constants.LogFile, constants.LogLevel)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        })

        <span class="cov10" title="20">return projectLogger</span>
}

// createLogger логирование в файл и в консоль
func createLogger(filename string, logLevel zapcore.Level) (*logger, error) <span class="cov3" title="2">{
        // формат времени "2006-01-02T15:04:05.000Z0700"
        config := zap.NewProductionEncoderConfig()
        config.EncodeTime = zapcore.ISO8601TimeEncoder

        // создание кодировщиков для вывода в файл и в консоль
        fileEncoder := zapcore.NewJSONEncoder(config)
        consoleEncoder := zapcore.NewConsoleEncoder(config)

        // Открываем лог файл
        logFile, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        // Create writers for file and console
        <span class="cov3" title="2">fileWriter := zapcore.AddSync(logFile)
        consoleWriter := zapcore.AddSync(os.Stdout)

        // Create cores for writing to the file and console
        fileCore := zapcore.NewCore(fileEncoder, fileWriter, logLevel)
        consoleCore := zapcore.NewCore(consoleEncoder, consoleWriter, logLevel)

        // Combine cores
        core := zapcore.NewTee(fileCore, consoleCore)

        // Create the logger with additional context information (caller, stack trace)
        l := &amp;logger{
                zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel)),
                filename,
        }

        return l, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package app Приложение Сервер
package app

import (
        "net/http"

        "github.com/dnsoftware/go-metrics/internal/logger"
        "github.com/dnsoftware/go-metrics/internal/server/collector"
        "github.com/dnsoftware/go-metrics/internal/server/config"
        "github.com/dnsoftware/go-metrics/internal/server/handlers"
        "github.com/dnsoftware/go-metrics/internal/storage"
)

func ServerRun() <span class="cov0" title="0">{
        srvLogger := logger.Log()
        defer srvLogger.Sync()

        cfg := config.NewServerConfig()

        backupStorage, err := storage.NewBackupStorage(cfg.FileStoragePath)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var (
                repo    collector.ServerStorage
                collect *collector.Collector
        )

        repo, err = storage.NewPostgresqlStorage(cfg.DatabaseDSN)
        if err != nil </span><span class="cov0" title="0">{ // значит база НЕ рабочая - используем Memory
                repo = storage.NewMemStorage()
        }</span>

        <span class="cov0" title="0">collect, err = collector.NewCollector(cfg, repo, backupStorage)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">server := handlers.NewHTTPServer(collect, cfg.CryptoKey)

        err = http.ListenAndServe(cfg.ServerAddress, server.Router)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package collector сборщик метрик, получаемых от Агента
package collector

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/dnsoftware/go-metrics/internal/logger"
        "github.com/dnsoftware/go-metrics/internal/server/config"
        _ "github.com/golang/mock/mockgen/model"
)

// ServerStorage сохраняет метрики в хранилище, получает метрики из хранилища.
// Получает дамп данных хранилища, восстанавливает базу данных из дампа.
type ServerStorage interface {
        // SetGauge сохранение метрики типа gauge в хранилище.
        // Параметры: name - название метрики, value - ее значение.
        SetGauge(ctx context.Context, name string, value float64) error

        // SetCounter сохранение метрики типа counter в хранилище.
        // Параметры: name - название метрики, value - ее значение.
        SetCounter(ctx context.Context, name string, value int64) error

        // SetBatch сохраняет метрики в базу пакетом из нескольких штук
        SetBatch(ctx context.Context, batch []byte) error

        // GetGauge получение значения метрики типа gauge из хранилища.
        // Параметры: name - название метрики.
        GetGauge(ctx context.Context, name string) (float64, error)

        // GetCounter получение значения метрики типа counter из хранилища.
        // Параметры: name - название метрики.
        GetCounter(ctx context.Context, name string) (int64, error)

        // GetAll получение всех метрик. Возвращает карты gauge и counters
        GetAll(ctx context.Context) (map[string]float64, map[string]int64, error)

        // GetDump получение дампа базы данных
        GetDump(ctx context.Context) (string, error)

        // RestoreFromDump восстановление в базу данных из дампа
        RestoreFromDump(ctx context.Context, dump string) error

        // DatabasePing проверяет работоспособность БД
        DatabasePing(ctx context.Context) bool
}

// BackupStorage работает с резервной копией БД. Сохранение дампа в базу и получение дампа базы.
type BackupStorage interface {
        Save(dump string) error
        Load() (string, error)
}

// Collector работает с метриками. Сохраняет их в базу и получает их из базы.
type Collector struct {
        cfg           *config.ServerConfig
        storage       ServerStorage
        backupStorage BackupStorage
}

// gaugeMetricsList список доступных gauge метрик
var gaugeMetricsList = []string{"Alloc", "BuckHashSys", "Frees", "GCCPUFraction", "GCSys", "HeapAlloc", "HeapIdle", "HeapInuse", "HeapObjects", "HeapReleased", "HeapSys", "LastGC", "Lookups", "MCacheInuse", "MCacheSys", "MSpanInuse", "MSpanSys", "Mallocs", "NextGC", "NumForcedGC", "NumGC", "OtherSys", "PauseTotalNs", "StackInuse", "StackSys", "Sys", "TotalAlloc", "RandomValue"}

func NewCollector(cfg *config.ServerConfig, storage ServerStorage, backupStorage BackupStorage) (*Collector, error) <span class="cov10" title="8">{
        collector := &amp;Collector{
                cfg:           cfg,
                storage:       storage,
                backupStorage: backupStorage,
        }

        // Загружаем сохраненную базу, если нужно
        if cfg.RestoreSaved </span><span class="cov0" title="0">{
                err := collector.LoadFromDump()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov10" title="8">collector.startBackup()

        return collector, nil</span>
}

// IsMetric проверка на допустимую метрику
func (c *Collector) IsMetric(mType string, name string) bool <span class="cov5" title="3">{

        if mType == constants.Gauge </span><span class="cov1" title="1">{
                for _, val := range gaugeMetricsList </span><span class="cov1" title="1">{
                        if val == name </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov4" title="2">if mType == constants.Counter </span><span class="cov1" title="1">{
                if name == constants.PollCount </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

// SetGaugeMetric сохранение метрики типа gauge.
// Параметры: metricName - название метрики, metricValue - ее значение.
func (c *Collector) SetGaugeMetric(ctx context.Context, metricName string, metricValue float64) error <span class="cov5" title="3">{
        err := c.storage.SetGauge(ctx, metricName, metricValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // если бэкап синхронный и указан файл
        <span class="cov5" title="3">if c.cfg.StoreInterval == constants.BackupPeriodSync &amp;&amp; c.cfg.FileStoragePath != "" </span><span class="cov0" title="0">{
                err = c.GenerateDump()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">return nil</span>
}

// GetGaugeMetric получение значения метрики типа gauge.
// Параметры: metricName - название метрики.
func (c *Collector) GetGaugeMetric(ctx context.Context, metricName string) (float64, error) <span class="cov5" title="3">{
        return c.storage.GetGauge(ctx, metricName)
}</span>

// SetCounterMetric сохранение метрики типа counter.
// Параметры: metricName - название метрики, metricValue - ее значение.
// Прибавляем к уже существующему значению
func (c *Collector) SetCounterMetric(ctx context.Context, metricName string, metricValue int64) error <span class="cov5" title="3">{
        oldVal, _ := c.storage.GetCounter(ctx, metricName)
        newVal := oldVal + metricValue

        err := c.storage.SetCounter(ctx, metricName, newVal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // если бэкап синхронный и указан файл
        <span class="cov5" title="3">if c.cfg.StoreInterval == constants.BackupPeriodSync &amp;&amp; c.cfg.FileStoragePath != "" </span><span class="cov0" title="0">{
                errB := c.GenerateDump()
                if errB != nil </span><span class="cov0" title="0">{
                        return errB
                }</span>
        }

        <span class="cov5" title="3">return nil</span>
}

// SetBatchMetrics сохраняет метрики в базу пакетом из нескольких штук
func (c *Collector) SetBatchMetrics(ctx context.Context, batch []byte) error <span class="cov1" title="1">{
        return c.storage.SetBatch(ctx, batch)
}</span>

// GetCounterMetric получение значения метрики типа counter.
// Параметры: metricName - название метрики.
func (c *Collector) GetCounterMetric(ctx context.Context, metricName string) (int64, error) <span class="cov4" title="2">{
        return c.storage.GetCounter(ctx, metricName)
}</span>

// GetMetric получение метрики в текстовом виде
func (c *Collector) GetMetric(ctx context.Context, metricType string, metricName string) (string, error) <span class="cov7" title="4">{
        var valStr string

        switch metricType </span>{
        case constants.Gauge:<span class="cov4" title="2">
                val, err := c.GetGaugeMetric(ctx, metricName)
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>

                <span class="cov1" title="1">valStr = strconv.FormatFloat(val, 'f', -1, 64)</span>

        case constants.Counter:<span class="cov1" title="1">
                val, err := c.GetCounterMetric(ctx, metricName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov1" title="1">valStr = strconv.FormatInt(val, 10)</span>
        default:<span class="cov1" title="1">
                return "", errors.New("bad metric type")</span>
        }

        <span class="cov4" title="2">return valStr, nil</span>
}

// GetAll все метрики списком
func (c *Collector) GetAll(ctx context.Context) (string, error) <span class="cov1" title="1">{
        gauges, counters, err := c.storage.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">mList := ""
        for key, val := range gauges </span><span class="cov1" title="1">{
                mList = mList + key + ": " + fmt.Sprintf("%f", val) + "\n"
        }</span>

        <span class="cov1" title="1">for key, val := range counters </span><span class="cov1" title="1">{
                mList = mList + key + ": " + strconv.FormatInt(val, 10) + "\n"
        }</span>

        <span class="cov1" title="1">return mList, nil</span>
}

// GenerateDump сохранение дампа в файл
func (c *Collector) GenerateDump() error <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.DBContextTimeout)
        defer cancel()

        dump, err := c.storage.GetDump(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error(err.Error())
                return err
        }</span>

        <span class="cov1" title="1">err = c.backupStorage.Save(dump)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error(err.Error())
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// LoadFromDump загрузка данных из дампа
func (c *Collector) LoadFromDump() error <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.DBContextTimeout)
        defer cancel()

        dump, err := c.backupStorage.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error(err.Error())
                return err
        }</span>

        // пустой файл
        <span class="cov1" title="1">if len(dump) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">err = c.storage.RestoreFromDump(ctx, dump)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error(err.Error())
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// startBackup периодическое сохранение метрик
func (c *Collector) startBackup() <span class="cov10" title="8">{
        // если обновление синхронное - не запускаем периодическое обновление
        if c.cfg.StoreInterval == constants.BackupPeriodSync </span><span class="cov10" title="8">{
                return
        }</span>

        // если файл не указан - не запускаем сохранение на диск
        <span class="cov0" title="0">if c.cfg.FileStoragePath == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">backupPeriod := time.Duration(c.cfg.StoreInterval) * time.Second

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(backupPeriod)

                        err := c.GenerateDump()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log().Error(err.Error())
                        }</span>
                }
        }()
}

// DatabasePing проверка работоспособности СУБД
func (c *Collector) DatabasePing(ctx context.Context) bool <span class="cov0" title="0">{
        return c.storage.DatabasePing(ctx)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/server/collector/collector.go

// Package mock_collector is a generated GoMock package.
package mock_collector

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockServerStorage is a mock of ServerStorage interface.
type MockServerStorage struct {
        ctrl     *gomock.Controller
        recorder *MockServerStorageMockRecorder
}

// MockServerStorageMockRecorder is the mock recorder for MockServerStorage.
type MockServerStorageMockRecorder struct {
        mock *MockServerStorage
}

// NewMockServerStorage creates a new mock instance.
func NewMockServerStorage(ctrl *gomock.Controller) *MockServerStorage <span class="cov0" title="0">{
        mock := &amp;MockServerStorage{ctrl: ctrl}
        mock.recorder = &amp;MockServerStorageMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServerStorage) EXPECT() *MockServerStorageMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DatabasePing mocks base method.
func (m *MockServerStorage) DatabasePing(ctx context.Context) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DatabasePing", ctx)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// DatabasePing indicates an expected call of DatabasePing.
func (mr *MockServerStorageMockRecorder) DatabasePing(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DatabasePing", reflect.TypeOf((*MockServerStorage)(nil).DatabasePing), ctx)
}</span>

// GetAll mocks base method.
func (m *MockServerStorage) GetAll(ctx context.Context) (map[string]float64, map[string]int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", ctx)
        ret0, _ := ret[0].(map[string]float64)
        ret1, _ := ret[1].(map[string]int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockServerStorageMockRecorder) GetAll(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockServerStorage)(nil).GetAll), ctx)
}</span>

// GetCounter mocks base method.
func (m *MockServerStorage) GetCounter(ctx context.Context, name string) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCounter", ctx, name)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCounter indicates an expected call of GetCounter.
func (mr *MockServerStorageMockRecorder) GetCounter(ctx, name interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCounter", reflect.TypeOf((*MockServerStorage)(nil).GetCounter), ctx, name)
}</span>

// GetDump mocks base method.
func (m *MockServerStorage) GetDump(ctx context.Context) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetDump", ctx)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetDump indicates an expected call of GetDump.
func (mr *MockServerStorageMockRecorder) GetDump(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDump", reflect.TypeOf((*MockServerStorage)(nil).GetDump), ctx)
}</span>

// GetGauge mocks base method.
func (m *MockServerStorage) GetGauge(ctx context.Context, name string) (float64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetGauge", ctx, name)
        ret0, _ := ret[0].(float64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetGauge indicates an expected call of GetGauge.
func (mr *MockServerStorageMockRecorder) GetGauge(ctx, name interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGauge", reflect.TypeOf((*MockServerStorage)(nil).GetGauge), ctx, name)
}</span>

// RestoreFromDump mocks base method.
func (m *MockServerStorage) RestoreFromDump(ctx context.Context, dump string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RestoreFromDump", ctx, dump)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RestoreFromDump indicates an expected call of RestoreFromDump.
func (mr *MockServerStorageMockRecorder) RestoreFromDump(ctx, dump interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoreFromDump", reflect.TypeOf((*MockServerStorage)(nil).RestoreFromDump), ctx, dump)
}</span>

// SetBatch mocks base method.
func (m *MockServerStorage) SetBatch(ctx context.Context, batch []byte) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetBatch", ctx, batch)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetBatch indicates an expected call of SetBatch.
func (mr *MockServerStorageMockRecorder) SetBatch(ctx, batch interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBatch", reflect.TypeOf((*MockServerStorage)(nil).SetBatch), ctx, batch)
}</span>

// SetCounter mocks base method.
func (m *MockServerStorage) SetCounter(ctx context.Context, name string, value int64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetCounter", ctx, name, value)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetCounter indicates an expected call of SetCounter.
func (mr *MockServerStorageMockRecorder) SetCounter(ctx, name, value interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCounter", reflect.TypeOf((*MockServerStorage)(nil).SetCounter), ctx, name, value)
}</span>

// SetGauge mocks base method.
func (m *MockServerStorage) SetGauge(ctx context.Context, name string, value float64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetGauge", ctx, name, value)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetGauge indicates an expected call of SetGauge.
func (mr *MockServerStorageMockRecorder) SetGauge(ctx, name, value interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGauge", reflect.TypeOf((*MockServerStorage)(nil).SetGauge), ctx, name, value)
}</span>

// MockBackupStorage is a mock of BackupStorage interface.
type MockBackupStorage struct {
        ctrl     *gomock.Controller
        recorder *MockBackupStorageMockRecorder
}

// MockBackupStorageMockRecorder is the mock recorder for MockBackupStorage.
type MockBackupStorageMockRecorder struct {
        mock *MockBackupStorage
}

// NewMockBackupStorage creates a new mock instance.
func NewMockBackupStorage(ctrl *gomock.Controller) *MockBackupStorage <span class="cov7" title="8">{
        mock := &amp;MockBackupStorage{ctrl: ctrl}
        mock.recorder = &amp;MockBackupStorageMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackupStorage) EXPECT() *MockBackupStorageMockRecorder <span class="cov10" title="16">{
        return m.recorder
}</span>

// Load mocks base method.
func (m *MockBackupStorage) Load() (string, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Load")
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Load indicates an expected call of Load.
func (mr *MockBackupStorageMockRecorder) Load() *gomock.Call <span class="cov7" title="8">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockBackupStorage)(nil).Load))
}</span>

// Save mocks base method.
func (m *MockBackupStorage) Save(dump string) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", dump)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockBackupStorageMockRecorder) Save(dump interface{}) *gomock.Call <span class="cov7" title="8">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockBackupStorage)(nil).Save), dump)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package config Конфигурация
package config

import (
        "flag"
        "log"
        "os"

        "github.com/caarlos0/env/v6"
        "github.com/dnsoftware/go-metrics/internal/constants"
)

// ServerConfig конфигурационные параметры сервера
type ServerConfig struct {
        ServerAddress   string `env:"ADDRESS"`
        StoreInterval   int64  `env:"STORE_INTERVAL" envDefault:"-1"`
        FileStoragePath string `env:"FILE_STORAGE_PATH" envDefault:"none"`
        RestoreSaved    bool   `env:"RESTORE" envDefault:"true"`
        DatabaseDSN     string `env:"DATABASE_DSN" envDefault:""`
        CryptoKey       string `env:"KEY" envDefault:""`
}

// serverFlags флаги конфигурации
type serverFlags struct {
        serverAddress   string
        storeInterval   int64
        fileStoragePath string
        restoreSaved    bool
        databaseDSN     string
        cryptoKey       string
}

func NewServerConfig() *ServerConfig <span class="cov0" title="0">{
        cfg := &amp;ServerConfig{}
        sf := serverFlags{}

        err := env.Parse(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">flag.StringVar(&amp;sf.serverAddress, "a", constants.ServerDefault, "server endpoint")
        flag.Int64Var(&amp;sf.storeInterval, "i", constants.StoreInterval, "store interval")
        flag.StringVar(&amp;sf.fileStoragePath, "f", constants.FileStoragePath, "file store path")
        flag.BoolVar(&amp;sf.restoreSaved, "r", constants.RestoreSaved, "to restore?")
        flag.StringVar(&amp;sf.databaseDSN, "d", "", "data source name")
        flag.StringVar(&amp;sf.cryptoKey, "k", "", "crypto key")
        flag.Parse()

        // если какого-то параметра нет в переменных окружения - берем значение флага, а если и флага нет - берем по умолчанию
        if cfg.ServerAddress == "" </span><span class="cov0" title="0">{
                cfg.ServerAddress = sf.serverAddress
        }</span>

        <span class="cov0" title="0">if cfg.StoreInterval == -1 </span><span class="cov0" title="0">{
                cfg.StoreInterval = sf.storeInterval
        }</span>

        <span class="cov0" title="0">if cfg.FileStoragePath == "none" </span><span class="cov0" title="0">{
                cfg.FileStoragePath = sf.fileStoragePath
        }</span>

        <span class="cov0" title="0">if _, ok := os.LookupEnv(constants.RestoreSavedEnv); !ok </span><span class="cov0" title="0">{
                cfg.RestoreSaved = sf.restoreSaved
        }</span>

        <span class="cov0" title="0">if cfg.DatabaseDSN == "" </span><span class="cov0" title="0">{
                cfg.DatabaseDSN = sf.databaseDSN
        }</span>

        <span class="cov0" title="0">if cfg.CryptoKey == "" </span><span class="cov0" title="0">{
                cfg.CryptoKey = sf.cryptoKey
        }</span>

        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "compress/gzip"
        "io"
        "net/http"

        "github.com/dnsoftware/go-metrics/internal/constants"
)

// compressWriter реализует интерфейс http.ResponseWriter и позволяет прозрачно для сервера
// сжимать передаваемые данные и выставлять правильные HTTP-заголовки
type compressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

func newCompressWriter(w http.ResponseWriter) *compressWriter <span class="cov0" title="0">{
        return &amp;compressWriter{
                w:  w,
                zw: gzip.NewWriter(w),
        }
}</span>

func (c *compressWriter) Header() http.Header <span class="cov0" title="0">{
        return c.w.Header()
}</span>

func (c *compressWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        return c.zw.Write(p)
}</span>

func (c *compressWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        c.w.Header().Set("Content-Encoding", constants.EncodingGzip)
        c.w.WriteHeader(statusCode)
}</span>

// Close закрывает gzip.Writer и досылает все данные из буфера.
func (c *compressWriter) Close() error <span class="cov0" title="0">{
        return c.zw.Close()
}</span>

// compressReader реализует интерфейс io.ReadCloser и позволяет прозрачно для сервера
// декомпрессировать получаемые от клиента данные
type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

func newCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov0" title="0">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

func (c compressReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return c.zr.Read(p)
}</span>

func (c *compressReader) Close() error <span class="cov0" title="0">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.zr.Close()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package handlers Обработчики HTTP запросов
package handlers

import (
        "context"
        "net/http"

        "github.com/go-chi/chi/v5/middleware"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/go-chi/chi/v5"

        _ "net/http/pprof"
)

// Collector сборщик метрик. Сохраняет метрики в хранилище. Получает метрики из  хранилища.
type Collector interface {
        // SetGaugeMetric сохранение метрики типа gauge.
        // Параметры: name - название метрики, value - ее значение.
        SetGaugeMetric(ctx context.Context, name string, value float64) error

        // SetCounterMetric сохранение метрики типа counter.
        // Параметры: name - название метрики, value - ее значение.
        SetCounterMetric(ctx context.Context, name string, value int64) error

        // SetBatchMetrics сохраняет метрики в базу пакетом из нескольких штук
        SetBatchMetrics(ctx context.Context, batch []byte) error

        // GetGaugeMetric получение значения метрики типа gauge.
        // Параметры: name - название метрики.
        GetGaugeMetric(ctx context.Context, name string) (float64, error)

        // GetCounterMetric получение значения метрики типа counter из хранилища.
        // Параметры: name - название метрики.
        GetCounterMetric(ctx context.Context, name string) (int64, error)

        // GetMetric получение метрики в текстовом виде
        GetMetric(ctx context.Context, metricType string, metricName string) (string, error)

        // GetAll получение всех метрик списком
        GetAll(ctx context.Context) (string, error)

        // DatabasePing проверка работоспособности СУБД
        DatabasePing(ctx context.Context) bool
}

type HTTPServer struct {
        collector Collector
        Router    chi.Router
}

// Metrics структура для получения json данных от агента
type Metrics struct {
        ID    string   `json:"id"`              // имя метрики
        MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
        Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
        Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
}

type (
        // структура для хранения сведений об ответе
        responseData struct {
                status int
                size   int
        }

        // расширенный ResponseWriter
        loggingResponseWriter struct {
                http.ResponseWriter // встраиваем оригинальный http.ResponseWriter
                responseData        *responseData
        }
)

func NewHTTPServer(collector Collector, cryptoKey string) HTTPServer <span class="cov10" title="21">{
        h := HTTPServer{
                collector: collector,
                Router:    NewRouter(),
        }

        h.Router.Use(trimEnd)
        h.Router.Use(CheckSignMiddleware(cryptoKey))
        h.Router.Use(GzipMiddleware)
        h.Router.Use(middleware.Compress(5))
        h.Router.Use(WithLogging)

        h.Router.Mount("/debug", middleware.Profiler())

        h.Router.Post("/", h.getAllMetrics)
        h.Router.Post("/"+constants.UpdateAction, h.UpdateMetricJSON)
        h.Router.Post("/"+constants.UpdateAction+"/{metricType}", h.noMetricName)
        h.Router.Post("/"+constants.UpdateAction+"/{metricType}/{metricName}", h.noMetricValue)
        h.Router.Post("/"+constants.UpdateAction+"/{metricType}/{metricName}/{metricValue}", h.UpdateMetric)
        h.Router.Post("/"+constants.UpdatesAction, h.UpdatesMetricJSON)

        h.Router.Post("/"+constants.ValueAction, h.getMetricValueJSON)

        h.Router.Get("/", h.getAllMetrics)
        h.Router.Get("/"+constants.ValueAction+"/{metricType}", h.noMetricName)
        h.Router.Get("/"+constants.ValueAction+"/{metricType}/{metricName}", h.getMetricValue)

        h.Router.Get("/ping", h.databasePing)

        return h
}</span>

func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="11">{
        // записываем ответ, используя оригинальный http.ResponseWriter
        size, err := r.ResponseWriter.Write(b)
        r.responseData.size += size // захватываем размер

        return size, err
}</span>

func (r *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov9" title="17">{
        // записываем код статуса, используя оригинальный http.ResponseWriter
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode // захватываем код статуса
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/dnsoftware/go-metrics/internal/logger"
        "go.uber.org/zap"
)

type Middleware func(http.Handler) http.Handler

// CheckSignMiddleware проверяет подпись переданных данныхпо алгоритму SHA256 (если это необходимо)
func CheckSignMiddleware(cryptoKey string) func(http.Handler) http.Handler <span class="cov10" title="21">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="21">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov9" title="17">{
                        if h := r.Header.Get(constants.HashHeaderName); h != "" </span><span class="cov0" title="0">{
                                // вычитываем тело запроса для проверки подписи, а потом записываем обратно
                                var buf bytes.Buffer

                                buf.ReadFrom(r.Body)
                                r.Body = io.NopCloser(bytes.NewBuffer(buf.Bytes()))

                                hs := hash(buf.Bytes(), cryptoKey)

                                if h != hs </span><span class="cov0" title="0">{
                                        http.Error(w, "Bad sign", http.StatusBadRequest)
                                        return
                                }</span>
                        }

                        <span class="cov9" title="17">next.ServeHTTP(w, r)</span>
                })
        }
}

func trimEnd(next http.Handler) http.Handler <span class="cov10" title="21">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov9" title="17">{

                if r.URL.Path == constants.PprofAction </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                }</span>

                // очистка от конечных пробелов
                <span class="cov9" title="17">r.URL.Path = strings.TrimSpace(r.URL.Path)
                // очистка от конечных слешей
                r.URL.Path = strings.TrimRight(r.URL.Path, "/")

                next.ServeHTTP(w, r)</span>
        })
}

// WithLogging добавляет дополнительный код для регистрации сведений о запросе
// и возвращает новый http.Handler.
func WithLogging(h http.Handler) http.Handler <span class="cov10" title="21">{
        logFn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov9" title="17">{
                start := time.Now()

                rd := &amp;responseData{
                        status: 0,
                        size:   0,
                }
                lw := loggingResponseWriter{
                        ResponseWriter: w, // встраиваем оригинальный http.ResponseWriter
                        responseData:   rd,
                }

                uri := r.RequestURI
                method := r.Method

                // вычитываем тело запроса для логирования, а потом записываем обратно
                var buf bytes.Buffer

                buf.ReadFrom(r.Body)
                r.Body = io.NopCloser(bytes.NewBuffer(buf.Bytes()))

                h.ServeHTTP(&amp;lw, r) // внедряем свою реализацию http.ResponseWriter

                // время выполнения запроса.
                duration := time.Since(start)

                // отправляем сведения о запросе в лог
                logger.Log().Info("request",
                        zap.String("uri", uri),
                        zap.String("method", method),
                        zap.Duration("duration", duration),
                        zap.Int("status", rd.status),
                        zap.Int("size", rd.size),
                        zap.String("body", buf.String()),
                )
        }</span>

        // возвращаем функционально расширенный хендлер
        <span class="cov10" title="21">return http.HandlerFunc(logFn)</span>
}

// GzipMiddleware распаковывает данные сжатые gzip, если это необходимо
func GzipMiddleware(h http.Handler) http.Handler <span class="cov10" title="21">{

        gzipFn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov9" title="17">{
                // по умолчанию устанавливаем оригинальный http.ResponseWriter как тот,
                // который будем передавать следующей функции
                outWriter := w

                // проверяем, что клиент отправил серверу сжатые данные в формате gzip
                contentEncoding := r.Header.Get("Content-Encoding")

                sendsGzip := strings.Contains(contentEncoding, constants.EncodingGzip)
                if sendsGzip </span><span class="cov0" title="0">{
                        // оборачиваем тело запроса в io.Reader с поддержкой декомпрессии
                        cr, err := newCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        // меняем тело запроса на новое
                        <span class="cov0" title="0">r.Body = cr
                        defer cr.Close()</span>
                }

                // внедряем свою реализацию http.ResponseWriter
                <span class="cov9" title="17">h.ServeHTTP(outWriter, r)</span>
        }

        <span class="cov10" title="21">return http.HandlerFunc(gzipFn)</span>
}

func hash(value []byte, key string) string <span class="cov0" title="0">{
        data := append(value, []byte(key)...)
        h := sha256.Sum256(data)

        return hex.EncodeToString(h[:])
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "bytes"
        "context"
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/go-chi/chi/v5"
)

func NewRouter() chi.Router <span class="cov10" title="21">{
        r := chi.NewRouter()
        return r
}</span>

// getAllMetrics получение всех метрик простым списком
func (h *HTTPServer) getAllMetrics(res http.ResponseWriter, req *http.Request) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        val, err := h.collector.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusNotFound)
        }</span>

        <span class="cov1" title="1">res.Header().Set("Content-Type", constants.TextHTML)
        res.WriteHeader(http.StatusOK)
        res.Write([]byte(val))</span>
}

// noMetricType ошибочный endpoint - не указан тип метрики.
func (h *HTTPServer) noMetricType(res http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        http.Error(res, "Metric type required!", http.StatusBadRequest)
}</span>

// noMetricName ошибочный endpoint - не указано название метрики.
func (h *HTTPServer) noMetricName(res http.ResponseWriter, _ *http.Request) <span class="cov1" title="1">{
        http.Error(res, "Metric name required!", http.StatusNotFound)
}</span>

// noMetricValue ошибочный endpoint - не указано значение метрики.
func (h *HTTPServer) noMetricValue(res http.ResponseWriter, _ *http.Request) <span class="cov1" title="1">{
        http.Error(res, "Metric value required!", http.StatusBadRequest)
}</span>

// UpdateMetric обновление одной метрики.
// Данные берутся из URL формата "/update/{metricType}/{metricName}/{metricValue}
func (h *HTTPServer) UpdateMetric(res http.ResponseWriter, req *http.Request) <span class="cov5" title="5">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        metricType := chi.URLParam(req, constants.MetricType)
        metricName := chi.URLParam(req, constants.MetricName)
        metricValue := chi.URLParam(req, constants.MetricValue)

        if metricType != constants.Gauge &amp;&amp; metricType != constants.Counter </span><span class="cov0" title="0">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="5">if metricType == constants.Gauge </span><span class="cov3" title="2">{
                gaugeVal, err := strconv.ParseFloat(metricValue, 64)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Incorrect metric value!", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov3" title="2">err = h.collector.SetGaugeMetric(ctx, metricName, gaugeVal)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, err.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov3" title="2">res.WriteHeader(http.StatusOK)</span>
        }

        <span class="cov5" title="5">if metricType == constants.Counter </span><span class="cov4" title="3">{
                counterVal, err := strconv.ParseInt(metricValue, 10, 64)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Incorrect metric value!", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov4" title="3">err = h.collector.SetCounterMetric(ctx, metricName, counterVal)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, err.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov4" title="3">res.WriteHeader(http.StatusOK)</span>
        }
}

// UpdateMetricJSON обновление одной метрики. Данные передаются в json формате
func (h *HTTPServer) UpdateMetricJSON(res http.ResponseWriter, req *http.Request) <span class="cov3" title="2">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        var buf bytes.Buffer

        var metrics Metrics

        _, err := buf.ReadFrom(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="2">if err = json.Unmarshal(buf.Bytes(), &amp;metrics); err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="2">if metrics.MType != constants.Gauge &amp;&amp; metrics.MType != constants.Counter </span><span class="cov0" title="0">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="2">if metrics.MType == constants.Gauge </span><span class="cov1" title="1">{
                errG := h.collector.SetGaugeMetric(ctx, metrics.ID, *metrics.Value)
                if errG != nil </span><span class="cov0" title="0">{
                        http.Error(res, errG.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">newMetric, errG := h.collector.GetGaugeMetric(ctx, metrics.ID)
                if errG != nil </span><span class="cov0" title="0">{
                        http.Error(res, errG.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">respMetric := Metrics{
                        ID:    metrics.ID,
                        MType: metrics.MType,
                        Value: &amp;newMetric,
                }

                resp, errG := json.Marshal(respMetric)
                if errG != nil </span><span class="cov0" title="0">{
                        http.Error(res, errG.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov1" title="1">res.Header().Set("Content-Type", constants.ApplicationJSON)
                res.WriteHeader(http.StatusOK)
                res.Write(resp)</span>
        }

        <span class="cov3" title="2">if metrics.MType == constants.Counter </span><span class="cov1" title="1">{
                errC := h.collector.SetCounterMetric(ctx, metrics.ID, *metrics.Delta)
                if errC != nil </span><span class="cov0" title="0">{
                        http.Error(res, errC.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">newMetric, errC := h.collector.GetCounterMetric(ctx, metrics.ID)
                if errC != nil </span><span class="cov0" title="0">{
                        http.Error(res, errC.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">respMetric := Metrics{
                        ID:    metrics.ID,
                        MType: metrics.MType,
                        Delta: &amp;newMetric,
                }

                resp, errC := json.Marshal(respMetric)
                if errC != nil </span><span class="cov0" title="0">{
                        http.Error(res, errC.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov1" title="1">res.Header().Set("Content-Type", constants.ApplicationJSON)
                res.WriteHeader(http.StatusOK)
                res.Write(resp)</span>
        }
}

// UpdatesMetricJSON обновление метрик пакетом, json формат
func (h *HTTPServer) UpdatesMetricJSON(res http.ResponseWriter, req *http.Request) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        var buf bytes.Buffer

        _, err := buf.ReadFrom(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">err = h.collector.SetBatchMetrics(ctx, buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">res.Header().Set("Content-Type", constants.ApplicationJSON)
        res.WriteHeader(http.StatusOK)</span>
}

// getMetricValue получение одной метрики
// Данные берутся из URL формата "/value/{metricType}/{metricName}
func (h *HTTPServer) getMetricValue(res http.ResponseWriter, req *http.Request) <span class="cov4" title="3">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        metricType := chi.URLParam(req, constants.MetricType)
        metricName := chi.URLParam(req, constants.MetricName)

        if metricType != constants.Gauge &amp;&amp; metricType != constants.Counter </span><span class="cov0" title="0">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="3">val, err := h.collector.GetMetric(ctx, metricType, metricName)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusNotFound)
        }</span>

        <span class="cov4" title="3">res.WriteHeader(http.StatusOK)
        res.Write([]byte(val))</span>
}

// getMetricValueJSON получение значения одной метрики в формате json
func (h *HTTPServer) getMetricValueJSON(res http.ResponseWriter, req *http.Request) <span class="cov4" title="3">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        var buf bytes.Buffer

        var metrics Metrics

        _, err := buf.ReadFrom(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="3">if err = json.Unmarshal(buf.Bytes(), &amp;metrics); err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="3">if metrics.MType != constants.Gauge &amp;&amp; metrics.MType != constants.Counter </span><span class="cov0" title="0">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="3">switch metrics.MType </span>{
        case constants.Gauge:<span class="cov3" title="2">
                val, errG := h.collector.GetGaugeMetric(ctx, metrics.ID)
                if errG != nil </span><span class="cov0" title="0">{
                        http.Error(res, errG.Error(), http.StatusNotFound)
                }</span>

                <span class="cov3" title="2">metrics.Value = &amp;val</span>
        case constants.Counter:<span class="cov1" title="1">
                val, errC := h.collector.GetCounterMetric(ctx, metrics.ID)
                if errC != nil </span><span class="cov0" title="0">{
                        http.Error(res, errC.Error(), http.StatusNotFound)
                }</span>

                <span class="cov1" title="1">metrics.Delta = &amp;val</span>
        }

        <span class="cov4" title="3">resp, err := json.Marshal(metrics)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="3">res.Header().Set("Content-Type", constants.ApplicationJSON)
        res.WriteHeader(http.StatusOK)
        res.Write(resp)</span>
}

// RootHandler Deprecated: версия из первого инкремента
func (h *HTTPServer) RootHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="11">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        // only POST
        if req.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(res, "Only POST requests are allowed!", http.StatusMethodNotAllowed)
                return
        }</span>

        // очистка от конечных пробелов
        <span class="cov7" title="10">url := strings.TrimSpace(req.URL.Path)

        // mainpage
        if url == "/" </span><span class="cov0" title="0">{
                _, err := res.Write([]byte("Mainpage"))
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, "Incorrect metric type!", http.StatusInternalServerError)
                        return
                }</span>
        }

        // очистка от конечных слешей
        <span class="cov7" title="10">url = strings.TrimRight(url, "/")

        parts := strings.Split(url, "/")

        // тип метрики отсутствует
        if len(parts) &lt;= 2 </span><span class="cov1" title="1">{
                http.Error(res, "Incorrect metric type!", http.StatusBadRequest)
                return
        }</span>

        // некорректный тип метрики
        <span class="cov7" title="9">if parts[2] != constants.Gauge &amp;&amp; parts[2] != constants.Counter </span><span class="cov1" title="1">{
                http.Error(res, "Incorrect metric type!", http.StatusBadRequest)
                return
        }</span>

        // имя метрики отсутствует
        <span class="cov7" title="8">if len(parts) == 3 </span><span class="cov3" title="2">{
                http.Error(res, "Metric name required!", http.StatusNotFound)
                return
        }</span>

        // некорректное значение метрики (отсутствует)
        <span class="cov6" title="6">if len(parts) == 4 </span><span class="cov0" title="0">{
                http.Error(res, "Metric value required!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="6">switch parts[1] </span>{
        case constants.UpdateAction:<span class="cov5" title="5">
                metricType := parts[2]
                metricName := parts[3]

                if metricType == constants.Gauge </span><span class="cov3" title="2">{
                        gaugeVal, err := strconv.ParseFloat(parts[4], 64)

                        if err != nil </span><span class="cov1" title="1">{
                                http.Error(res, "Incorrect metric value!", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov1" title="1">err = h.collector.SetGaugeMetric(ctx, metricName, gaugeVal)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(res, err.Error(), http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov1" title="1">res.WriteHeader(http.StatusOK)</span>
                }

                <span class="cov5" title="4">if metricType == constants.Counter </span><span class="cov4" title="3">{
                        counterVal, err := strconv.ParseInt(parts[4], 10, 64)

                        if err != nil </span><span class="cov3" title="2">{
                                http.Error(res, "Incorrect metric value!", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov1" title="1">err = h.collector.SetCounterMetric(ctx, metricName, counterVal)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(res, err.Error(), http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov1" title="1">res.WriteHeader(http.StatusOK)</span>
                }

                <span class="cov3" title="2">return</span>

        default:<span class="cov1" title="1">
                h.unrecognized(res, req)</span>
        }
}

func (h *HTTPServer) unrecognized(res http.ResponseWriter, _ *http.Request) <span class="cov1" title="1">{
        http.Error(res, "Not found!", http.StatusNotFound)
}</span>

// databasePing пинг базы данных для проверки работоспособности
func (h *HTTPServer) databasePing(res http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(req.Context(), constants.DBContextTimeout)
        defer cancel()

        isConnected := h.collector.DatabasePing(ctx)

        if isConnected </span><span class="cov0" title="0">{
                res.WriteHeader(http.StatusOK)
        }</span> else<span class="cov0" title="0"> {
                res.WriteHeader(http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package app реализует свой статический анализатор
package app

import (
        "github.com/dnsoftware/go-metrics/internal/staticlint/noosexit"
        "github.com/nunnatsa/ginkgolinter"
        "github.com/timakin/bodyclose/passes/bodyclose"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/asmdecl"
        "golang.org/x/tools/go/analysis/passes/assign"
        "golang.org/x/tools/go/analysis/passes/atomic"
        "golang.org/x/tools/go/analysis/passes/atomicalign"
        "golang.org/x/tools/go/analysis/passes/bools"
        "golang.org/x/tools/go/analysis/passes/buildssa"
        "golang.org/x/tools/go/analysis/passes/buildtag"
        "golang.org/x/tools/go/analysis/passes/cgocall"
        "golang.org/x/tools/go/analysis/passes/composite"
        "golang.org/x/tools/go/analysis/passes/copylock"
        "golang.org/x/tools/go/analysis/passes/ctrlflow"
        "golang.org/x/tools/go/analysis/passes/deepequalerrors"
        "golang.org/x/tools/go/analysis/passes/directive"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/findcall"
        "golang.org/x/tools/go/analysis/passes/framepointer"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/ifaceassert"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/analysis/passes/loopclosure"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/nilfunc"
        "golang.org/x/tools/go/analysis/passes/nilness"
        "golang.org/x/tools/go/analysis/passes/pkgfact"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/reflectvaluecompare"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/sigchanyzer"
        "golang.org/x/tools/go/analysis/passes/sortslice"
        "golang.org/x/tools/go/analysis/passes/stdmethods"
        "golang.org/x/tools/go/analysis/passes/stringintconv"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/testinggoroutine"
        "golang.org/x/tools/go/analysis/passes/tests"
        "golang.org/x/tools/go/analysis/passes/timeformat"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "golang.org/x/tools/go/analysis/passes/unsafeptr"
        "golang.org/x/tools/go/analysis/passes/unusedresult"
        "golang.org/x/tools/go/analysis/passes/unusedwrite"
        "golang.org/x/tools/go/analysis/passes/usesgenerics"
        "honnef.co/go/tools/quickfix"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"
)

func StaticCheckerRun() <span class="cov0" title="0">{

        mychecks := []*analysis.Analyzer{
                printf.Analyzer,
                shadow.Analyzer,
                structtag.Analyzer,
                asmdecl.Analyzer,
                assign.Analyzer,
                atomic.Analyzer,
                atomicalign.Analyzer,
                bools.Analyzer,
                buildssa.Analyzer,
                buildtag.Analyzer,
                cgocall.Analyzer,
                composite.Analyzer,
                copylock.Analyzer,
                ctrlflow.Analyzer,
                deepequalerrors.Analyzer,
                directive.Analyzer,
                errorsas.Analyzer,
                //fieldalignment.Analyzer,
                findcall.Analyzer,
                framepointer.Analyzer,
                httpresponse.Analyzer,
                ifaceassert.Analyzer,
                inspect.Analyzer,
                loopclosure.Analyzer,
                lostcancel.Analyzer,
                nilfunc.Analyzer,
                nilness.Analyzer,
                pkgfact.Analyzer,
                reflectvaluecompare.Analyzer,
                shift.Analyzer,
                sigchanyzer.Analyzer,
                sortslice.Analyzer,
                stdmethods.Analyzer,
                stringintconv.Analyzer,
                testinggoroutine.Analyzer,
                tests.Analyzer,
                timeformat.Analyzer,
                unmarshal.Analyzer,
                unreachable.Analyzer,
                unsafeptr.Analyzer,
                unusedresult.Analyzer,
                unusedwrite.Analyzer,
                usesgenerics.Analyzer,
                bodyclose.Analyzer,    // проверяет, правильно ли закрыт res.Body.
                ginkgolinter.Analyzer, // Enforces standards of using ginkgo and gomega.
        }

        // staticcheck анализаторы
        for _, v := range staticcheck.Analyzers </span><span class="cov0" title="0">{
                mychecks = append(mychecks, v.Analyzer)
        }</span>

        // рефакторинг кода
        <span class="cov0" title="0">for _, v := range quickfix.Analyzers </span><span class="cov0" title="0">{
                mychecks = append(mychecks, v.Analyzer)
        }</span>

        // упрощение кода
        <span class="cov0" title="0">for _, v := range simple.Analyzers </span><span class="cov0" title="0">{
                mychecks = append(mychecks, v.Analyzer)
        }</span>

        // Содержит анализы, обеспечивающие соблюдение правил стиля. Большинство сделанных рекомендаций повсеместно
        // одобрены широким сообществом Go.
        // По большей части рекомендуется следовать советам анализаторов, которые включены по умолчанию,
        // но можно отключить дополнительный анализ в каждом конкретном случае.
        <span class="cov0" title="0">for _, v := range stylecheck.Analyzers </span><span class="cov0" title="0">{
                mychecks = append(mychecks, v.Analyzer)
        }</span>

        <span class="cov0" title="0">mychecks = append(mychecks, noosexit.OsExitAnalyzer)

        multichecker.Main(
                mychecks...,
        )</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package noosexit Анализатор вызова функции os.Exit в пакете main функции main()
package noosexit

import (
        "go/ast"

        "golang.org/x/tools/go/analysis"
)

var OsExitAnalyzer = &amp;analysis.Analyzer{
        Name: "noosexit",
        Doc:  "анализатор, запрещающий использовать прямой вызов os.Exit в функции main пакета main",
        Run:  run,
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov3" title="3">{

        for _, file := range pass.Files </span><span class="cov3" title="3">{

                if pass.Pkg.Name() != "main" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="3">ast.Inspect(file, func(n ast.Node) bool </span><span class="cov9" title="38">{

                        mainFunc, ok := n.(*ast.FuncDecl)
                        if !ok </span><span class="cov9" title="34">{
                                return true // переходим к дочерним узлам
                        }</span>

                        <span class="cov4" title="4">if mainFunc.Name.String() != "main" </span><span class="cov1" title="1">{
                                return false // функиция НЕ main - к дочерним узлам смысла переходить нет
                        }</span>

                        // переходим к разбору ф-ии main()
                        <span class="cov3" title="3">ast.Inspect(mainFunc, func(node ast.Node) bool </span><span class="cov10" title="45">{
                                call, okCall := node.(*ast.CallExpr)
                                if !okCall </span><span class="cov9" title="41">{ // если НЕ вызов ф-ии - пропускаем
                                        return true
                                }</span>

                                <span class="cov4" title="4">s, okSelector := call.Fun.(*ast.SelectorExpr)
                                if !okSelector </span><span class="cov1" title="1">{
                                        return true
                                }</span>

                                <span class="cov3" title="3">if s.Sel.Name == "Exit" </span><span class="cov2" title="2">{
                                        ident := s.X.(*ast.Ident)
                                        if ident.Name == "os" </span><span class="cov2" title="2">{
                                                pass.Reportf(s.Pos(), "Вызов os.Exit в функции main")
                                        }</span>
                                }

                                <span class="cov3" title="3">return false</span>
                        })

                        <span class="cov3" title="3">return false</span>
                })

        }

        <span class="cov3" title="3">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package storage

import (
        "bufio"
        "io"
        "os"
        "sync"
)

// BackupStorage работает с файловым хранилищем резервной копии базы данных
type BackupStorage struct {
        mutex      sync.Mutex
        Gauges     map[string]float64 `json:"gauges"`
        Counters   map[string]int64   `json:"counters"`
        backupFile *os.File
        scanner    *bufio.Scanner
}

func NewBackupStorage(filename string) (*BackupStorage, error) <span class="cov10" title="2">{
        // открываем
        file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">return &amp;BackupStorage{
                backupFile: file,
                scanner:    bufio.NewScanner(file),
        }, nil</span>
}

// Save сохранение в файл
func (b *BackupStorage) Save(dump string) error <span class="cov1" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()

        _, err := b.backupFile.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = b.backupFile.Truncate(0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">_, err = b.backupFile.Write([]byte(dump))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Load получение данных из файла
func (b *BackupStorage) Load() (string, error) <span class="cov1" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()

        data, err := io.ReadAll(b.backupFile)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return string(data), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "errors"
        "sync"

        "github.com/dnsoftware/go-metrics/internal/constants"
)

// MemStorage работает с хранилищем в оперативной памяти
type MemStorage struct {
        mutex    sync.Mutex
        Gauges   map[string]float64 `json:"gauges"`
        Counters map[string]int64   `json:"counters"`
}

func NewMemStorage() *MemStorage <span class="cov5" title="6">{
        return &amp;MemStorage{
                Gauges:   make(map[string]float64),
                Counters: make(map[string]int64),
        }
}</span>

// SetGauge сохранение метрики типа gauge в хранилище.
// Параметры: name - название метрики, value - ее значение.
func (m *MemStorage) SetGauge(ctx context.Context, name string, value float64) error <span class="cov3" title="3">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.Gauges[name] = value

        return nil
}</span>

// GetGauge получение значения метрики типа gauge из хранилища.
// Параметры: name - название метрики.
func (m *MemStorage) GetGauge(ctx context.Context, name string) (float64, error) <span class="cov1" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if value, ok := m.Gauges[name]; ok </span><span class="cov1" title="1">{
                return value, nil
        }</span>

        <span class="cov0" title="0">return 0, errors.New("no such metric")</span>
}

// SetCounter сохранение метрики типа counter в хранилище.
// Параметры: name - название метрики, value - ее значение.
func (m *MemStorage) SetCounter(ctx context.Context, name string, value int64) error <span class="cov3" title="3">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.Counters[name] = value

        return nil
}</span>

// SetBatch сохраняет метрики в базу пакетом из нескольких штук
func (m *MemStorage) SetBatch(ctx context.Context, batch []byte) error <span class="cov1" title="1">{
        var metrics []Metrics

        m.mutex.Lock()
        defer m.mutex.Unlock()

        err := json.Unmarshal(batch, &amp;metrics)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">for _, mt := range metrics </span><span class="cov10" title="35">{
                if mt.MType == constants.Gauge </span><span class="cov9" title="34">{
                        m.Gauges[mt.ID] = *mt.Value
                }</span>

                <span class="cov10" title="35">if mt.MType == constants.Counter </span><span class="cov1" title="1">{
                        m.Counters[mt.ID] = *mt.Delta
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// GetCounter получение значения метрики типа counter из хранилища.
// Параметры: name - название метрики.
func (m *MemStorage) GetCounter(ctx context.Context, name string) (int64, error) <span class="cov1" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if value, ok := m.Counters[name]; ok </span><span class="cov1" title="1">{
                return value, nil
        }</span>

        <span class="cov0" title="0">return 0, errors.New("no such metric")</span>
}

// GetAll возврат карт gauge и counters
func (m *MemStorage) GetAll(ctx context.Context) (map[string]float64, map[string]int64, error) <span class="cov2" title="2">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        return m.Gauges, m.Counters, nil
}</span>

// GetDump получение json дампа
func (m *MemStorage) GetDump(ctx context.Context) (string, error) <span class="cov1" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        data, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return string(data), nil</span>
}

// RestoreFromDump восстановление из json дампа
func (m *MemStorage) RestoreFromDump(ctx context.Context, dump string) error <span class="cov1" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        err := json.Unmarshal([]byte(dump), m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DatabasePing проверяет работоспособность БД
func (m *MemStorage) DatabasePing(ctx context.Context) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package storage

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/dnsoftware/go-metrics/internal/constants"
        "github.com/dnsoftware/go-metrics/internal/logger"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
        _ "github.com/jackc/pgx/v5/stdlib"
)

// PgStorage работает с Postgresql базой данных
type PgStorage struct {
        db *sql.DB
}

// Gauge для получения метрики counter из БД
type Gauge struct {
        name  string
        value float64
}

// Counter для получения метрики counter из БД
type Counter struct {
        name  string
        value int64
}

// DumpData карты gauges и counters для получения дампа БД
type DumpData struct {
        Gauges   map[string]float64 `json:"gauges"`
        Counters map[string]int64   `json:"counters"`
}

func NewPostgresqlStorage(dsn string) (*PgStorage, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.DBContextTimeout)
        defer cancel()

        db, err := sql.Open("pgx", dsn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log().Error(err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">ps := &amp;PgStorage{
                db: db,
        }

        // создание таблиц, если не существуют
        err = ps.createDatabaseTables(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ps, nil</span>
}

// createDatabaseTables формирование структуры БД
func (p *PgStorage) createDatabaseTables(ctx context.Context) error <span class="cov0" title="0">{
        var query string

        // gauges
        query = `CREATE TABLE IF NOT EXISTS gauges
                        (
                            id character varying(64) PRIMARY KEY,
                            val double precision NOT NULL,
                            updated_at timestamp with time zone NOT NULL
                        )`

        err := p.retryExec(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // counters
        <span class="cov0" title="0">query = `CREATE TABLE IF NOT EXISTS counters
                        (
                            id character varying(64) PRIMARY KEY,
                            val bigint NOT NULL,
                            updated_at timestamp with time zone NOT NULL
                        )`

        err = p.retryExec(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// retryExec выполнение операции вставки/обновления несколькими попытками, если необходимо
func (p *PgStorage) retryExec(ctx context.Context, query string, args ...any) error <span class="cov0" title="0">{
        durations := strings.Split(constants.HTTPAttemtPeriods, ",")

        _, err := p.db.ExecContext(ctx, query, args...)

        var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) &amp;&amp; pgerrcode.IsConnectionException(pgErr.Code) </span><span class="cov0" title="0">{
                for _, duration := range durations </span><span class="cov0" title="0">{
                        d, _ := time.ParseDuration(duration)
                        time.Sleep(d)

                        _, err = p.db.ExecContext(ctx, query, args...)
                        if err == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("retryExec | ConnectionException: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("retryExec: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetGauge сохранение метрики типа gauge в хранилище.
// Параметры: name - название метрики, value - ее значение.
func (p *PgStorage) SetGauge(ctx context.Context, name string, value float64) error <span class="cov0" title="0">{
        query := `INSERT INTO gauges (id, val, updated_at)
                        VALUES ($1, $2, now())
                        ON CONFLICT (id)
                        DO UPDATE
                        SET id = $1, val = $2`

        err := p.retryExec(ctx, query, name, value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | SetGauge: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetGauge получение значения метрики типа gauge из хранилища.
// Параметры: name - название метрики.
func (p *PgStorage) GetGauge(ctx context.Context, name string) (float64, error) <span class="cov0" title="0">{
        query := `SELECT val FROM gauges WHERE id = $1`
        row := p.db.QueryRowContext(ctx, query, name)

        var val float64

        err := row.Scan(&amp;val)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("PgStorage | GetGauge: %w", err)
        }</span>

        <span class="cov0" title="0">return val, nil</span>
}

// SetCounter сохранение метрики типа counter в хранилище.
// Параметры: name - название метрики, value - ее значение.
func (p *PgStorage) SetCounter(ctx context.Context, name string, value int64) error <span class="cov0" title="0">{
        query := `INSERT INTO counters (id, val, updated_at)
                        VALUES ($1, $2, now())
                        ON CONFLICT (id)
                        DO UPDATE
                        SET id = $1, val = $2`

        err := p.retryExec(ctx, query, name, value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | SetCounter: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetBatch сохраняет метрики в базу пакетом из нескольких штук
func (p *PgStorage) SetBatch(ctx context.Context, batch []byte) error <span class="cov0" title="0">{
        var metrics []Metrics

        err := json.Unmarshal(batch, &amp;metrics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | SetBatch | json.Unmarshal: %w", err)
        }</span>

        /* Логика нижеследующего кода (реализация одного запроса INSERT со множеством значений сразу):

        Используется SQL запрос вида:
                INSERT INTO gauges (id, val, updated_at)
                VALUES ($1, $2, now()), ($3, $4, now()),...
                ON CONFLICT (id)
                DO UPDATE
                SET val = EXCLUDED.val, updated_at = now()

        параметры для подстановки имеют нумерацию по принципу:
                $1, $2 - название метрики, значение метрики для первой записи
                $3, $4 - название метрики, значение метрики для второй записи
                ...

        поэтому формируем срезы таких данных:
                gaugesKeyVal - для gauges
                countersKeyVal - для counters
        для дальнейшей генерации SQL запроса:
                p.db.ExecContext(ctx, query, gaugesKeyVal...)
                p.db.ExecContext(ctx, query, countersKeyVal...)

        далее вылез еще один момент:
                при обновлении в одном пакете одной и той же записи в базе, код
                        ON CONFLICT (id)
                        DO UPDATE
                        SET val = EXCLUDED.val, updated_at = now()
                дает ошибку
                        ERROR: ON CONFLICT DO UPDATE command cannot affect row a second time (SQLSTATE 21000)
                то есть второй раз не может повлиять на запись
                из-за этого не проходит автотест, с данными вида:
                        [{"id":"CounterBatchZip146","type":"counter","delta":35154714},
                         {"id":"GaugeBatchZip188","type":"gauge","value":18032.255593532198},
                         {"id":"CounterBatchZip146","type":"counter","delta":1872525169},
                         {"id":"GaugeBatchZip188","type":"gauge","value":37453.22976261069}]

        поэтому предварительно формируется карты метрик (data), куда записываются:
                - последнее значение gauge метрики, так как она перезаписывает текущую
                - сумма значений counter метрик, так как они прибавляются к текущему
                что дает нам однократное обновление уникальных записей в запросе

        может быть есть более изящное решение, но я его не придумал))
        доклад закончил!)))
        */

        // карта предварительно подготовленных метрик
        <span class="cov0" title="0">data := make(map[string]Metrics)

        for _, mt := range metrics </span><span class="cov0" title="0">{
                if mt.MType == constants.Gauge </span><span class="cov0" title="0">{
                        data[mt.ID] = mt
                }</span>

                <span class="cov0" title="0">if mt.MType == constants.Counter </span><span class="cov0" title="0">{
                        if v, ok := data[mt.ID]; ok </span><span class="cov0" title="0">{
                                vd := *v.Delta + *mt.Delta
                                v.Delta = &amp;vd
                                data[mt.ID] = v

                                continue</span>
                        }

                        <span class="cov0" title="0">data[mt.ID] = mt</span>
                }
        }

        <span class="cov0" title="0">var (
                gaugesKeyVal     []any    // срез пар значений для подстановки в SQL запрос вставки/обновления gauges
                countersKeyVal   []any    // срез пар значений для подстановки в SQL запрос вставки/обновления counters
                gaugeTemplates   []string // срез для формирования фрагмента множественной вставки gauges
                counterTemplates []string // срез для формирования фрагмента множественной вставки counters
                g                int64    // счетчик цикла gauges
                c                int64    // счетчик цикла counters
        )

        // формирование данных для генерации запроса множественной вставки
        for _, mt := range data </span><span class="cov0" title="0">{
                if mt.MType == constants.Gauge </span><span class="cov0" title="0">{
                        g++
                        val1 := g
                        g++
                        val2 := g
                        gaugeTemplates = append(gaugeTemplates, fmt.Sprintf("($%d, $%d, now())", val1, val2))
                        gaugesKeyVal = append(gaugesKeyVal, mt.ID, mt.Value)
                }</span>

                <span class="cov0" title="0">if mt.MType == constants.Counter </span><span class="cov0" title="0">{
                        c++
                        val1 := c
                        c++
                        val2 := c
                        counterTemplates = append(counterTemplates, fmt.Sprintf("($%d, $%d, now())", val1, val2))
                        countersKeyVal = append(countersKeyVal, mt.ID, mt.Delta)
                }</span>
        }

        // старт транзакции
        <span class="cov0" title="0">tx, err := p.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | SetBatch | p.db.Begin(): %w", err)
        }</span>

        <span class="cov0" title="0">if len(gaugeTemplates) &gt; 0 </span><span class="cov0" title="0">{
                query := `INSERT INTO gauges (id, val, updated_at)
                        VALUES ` + strings.Join(gaugeTemplates, ",") + `
                        ON CONFLICT (id)
                        DO UPDATE
                        SET val = EXCLUDED.val, updated_at = now()`

                errR := p.retryExec(ctx, query, gaugesKeyVal...)
                if errR != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("PgStorage | SetBatch | Upsert gauge: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if len(counterTemplates) &gt; 0 </span><span class="cov0" title="0">{
                query := `INSERT INTO counters (id, val, updated_at)
                        VALUES ` + strings.Join(counterTemplates, ",") + `
                        ON CONFLICT (id)
                        DO UPDATE
                        SET val = counters.val + EXCLUDED.val, updated_at = now()`

                errR := p.retryExec(ctx, query, countersKeyVal...)
                if errR != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("PgStorage | SetBatch | Upsert counter: %w", err)
                }</span>
        }

        // завершаем транзакцию
        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | SetBatch | Commit: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetCounter получение значения метрики типа counter из хранилища.
// Параметры: name - название метрики.
func (p *PgStorage) GetCounter(ctx context.Context, name string) (int64, error) <span class="cov0" title="0">{
        query := `SELECT val FROM counters WHERE id = $1`
        row := p.db.QueryRowContext(ctx, query, name)

        var val int64

        err := row.Scan(&amp;val)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("PgStorage | GetCounter: %w", err)
        }</span>

        <span class="cov0" title="0">return val, nil</span>
}

// GetAll возврат всех метрик (карт gauge и counters)
func (p *PgStorage) GetAll(ctx context.Context) (map[string]float64, map[string]int64, error) <span class="cov0" title="0">{
        // gauges
        gRows, err := p.db.QueryContext(ctx, `SELECT id, val FROM gauges`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("PgStorage | GetAll | gauges: %w", err)
        }</span>
        <span class="cov0" title="0">defer gRows.Close()

        dump := DumpData{
                Gauges:   make(map[string]float64),
                Counters: make(map[string]int64),
        }

        for gRows.Next() </span><span class="cov0" title="0">{
                v := Gauge{}

                err = gRows.Scan(&amp;v.name, &amp;v.value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("PgStorage | GetAll | gauges Next: %w", err)
                }</span>

                <span class="cov0" title="0">dump.Gauges[v.name] = v.value</span>
        }

        <span class="cov0" title="0">err = gRows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("PgStorage | GetAll | gauges Next during iteration: %w", err)
        }</span>

        // counters
        <span class="cov0" title="0">cRows, err := p.db.QueryContext(ctx, `SELECT id, val FROM counters`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("PgStorage | GetAll | counters: %w", err)
        }</span>
        <span class="cov0" title="0">defer cRows.Close()

        for cRows.Next() </span><span class="cov0" title="0">{
                v := Counter{}

                err = cRows.Scan(&amp;v.name, &amp;v.value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("PgStorage | GetAll | counters Next: %w", err)
                }</span>

                <span class="cov0" title="0">dump.Counters[v.name] = v.value</span>
        }

        <span class="cov0" title="0">err = cRows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("PgStorage | GetAll | counters Next during iteration: %w", err)
        }</span>

        <span class="cov0" title="0">return dump.Gauges, dump.Counters, nil</span>
}

// GetDump получение json дампа БД
func (p *PgStorage) GetDump(ctx context.Context) (string, error) <span class="cov0" title="0">{
        dump := DumpData{}

        var err error

        dump.Gauges, dump.Counters, err = p.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("PgStorage | GetDump | GetAll: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(dump)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("PgStorage | GetDump | json.Marshal: %w", err)
        }</span>

        <span class="cov0" title="0">return string(data), nil</span>
}

// RestoreFromDump восстановление БД из json дампа
func (p *PgStorage) RestoreFromDump(ctx context.Context, dump string) error <span class="cov0" title="0">{
        data := DumpData{}

        err := json.Unmarshal([]byte(dump), &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | RestoreFromDump | json.Unmarshal: %w", err)
        }</span>

        // старт транзакции
        <span class="cov0" title="0">tx, err := p.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | RestoreFromDump | Tx begin: %w", err)
        }</span>

        <span class="cov0" title="0">queryDel := `TRUNCATE gauges, counters`

        err = p.retryExec(ctx, queryDel)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("PgStorage | RestoreFromDump | Truncate: %w", err)
        }</span>

        <span class="cov0" title="0">stmt, err := p.db.Prepare(`INSERT INTO gauges (id, val, updated_at)
                        VALUES ($1, $2, now())`)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("PgStorage | RestoreFromDump | Prepare gauges: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        for name, val := range data.Gauges </span><span class="cov0" title="0">{
                _, err = stmt.ExecContext(ctx, name, val)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("PgStorage | RestoreFromDump | Insert gauge: %w", err)
                }</span>
        }

        <span class="cov0" title="0">stmt, err = p.db.Prepare(`INSERT INTO counters (id, val, updated_at)
                        VALUES ($1, $2, now())`)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("PgStorage | RestoreFromDump | Prepare counters: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        for name, val := range data.Counters </span><span class="cov0" title="0">{
                _, err = stmt.ExecContext(ctx, name, val)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("PgStorage | RestoreFromDump | Insert counter: %w", err)
                }</span>
        }

        // завершаем транзакцию
        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PgStorage | RestoreFromDump | Commit: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DatabasePing проверка работоспособности соединения с БД
func (p *PgStorage) DatabasePing(ctx context.Context) bool <span class="cov0" title="0">{
        return p.db.PingContext(ctx) == nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
